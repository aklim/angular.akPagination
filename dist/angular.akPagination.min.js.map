{"version":3,"sources":["angular.akPagination.min.js"],"names":["akPaginateDirective","$compile","$parse","paginationService","dirPaginationCompileFn","tElement","tAttrs","expression","akPaginate","match","filterPattern","itemsPerPageFilterRemoved","replace","collectionGetter","addNoCompileAttributes","rawId","paginationId","DEFAULT_ID","registerInstance","scope","element","attrs","repeatExpression","getRepeatExpression","addNgRepeatToElement","removeTemporaryAttributes","compiled","currentPageGetter","makeCurrentPageGetterFn","setCurrentPageParser","totalItems","setAsyncModeTrue","$watch","result","setCollectionLength","setAsyncModeFalse","$watchCollection","collection","collectionLength","Array","length","Object","keys","idDefinedInFilter","hasAttribute","$set","eq","attr","angular","forEach","el","nodeType","removeAttr","currentPage","defaultCurrentPage","terminal","multiElement","priority","compile","noCompileDirective","dirPaginationControlsTemplateInstaller","$templateCache","put","akPaginationControlsDirective","paginationTemplate","akPaginationControlsLinkFn","goToPage","num","isRegistered","isValidPageNumber","oldPageNumber","pagination","current","pages","generatePagesArray","getCollectionLength","getItemsPerPage","paginationRange","updateRangeValues","onPageChange","newPageNumber","generatePagination","page","parseInt","getCurrentPage","last","setCurrent","itemsPerPage","range","lower","upper","Math","min","total","numberRegex","test","idMessage","window","console","warn","maxSize","autoHide","undefined","directionLinks","isDefined","$parent","$eval","boundaryLinks","max","val","previous","previousPage","setCurrentPage","tracker","id","index","rowsPerPage","position","totalPages","ceil","halfWay","ellipsesNeeded","i","pageNumber","calculatePageNumber","openingEllipsesNeeded","closingEllipsesNeeded","push","DDO","restrict","link","templateString","getString","template","templateUrl","elem","getPath","itemsPerPageFilter","end","start","isObject","isAsyncMode","setItemsPerPage","slice","slicedObject","key","obj","objKeys","hasOwnProperty","lastRegisteredInstance","instances","this","instanceId","asyncMode","deregisterInstance","getLastInstanceId","currentPageParser","context","assign","parser","paginationTemplateProvider","templatePath","setPath","path","setString","str","$get","moduleName","module","directive","filter","service","provider","run"],"mappings":"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","file":"angular.akPagination.min.js","sourcesContent":["\"use strict\";\n\n(function() {\n/**\n * angular.akPagination - AngularJS pagination module.\n *\n * Copyright 2017 Andrey Klimenko <andrey.iemail@gmail.com>\n */\n\n(function () {\n    /**\n     * Config\n     */\n    var moduleName = 'angular.akPagination';\n    var DEFAULT_ID = '__default';\n\n    /**\n     * Module\n     */\n    angular.module(moduleName, [])\n           .directive('akPaginate', ['$compile', '$parse', 'paginationService', akPaginateDirective])\n           .directive('dirPaginateNoCompile', noCompileDirective)\n           .directive('akPaginationControls', ['paginationService', 'paginationTemplate',\n               akPaginationControlsDirective])\n           .filter('itemsPerPage', ['paginationService', itemsPerPageFilter])\n           .service('paginationService', paginationService)\n           .provider('paginationTemplate', paginationTemplateProvider)\n           .run(['$templateCache', dirPaginationControlsTemplateInstaller]);\n\n    function akPaginateDirective($compile, $parse, paginationService) {\n\n        return {\n            terminal:     true,\n            multiElement: true,\n            priority:     100,\n            compile:      dirPaginationCompileFn\n        };\n\n        function dirPaginationCompileFn(tElement, tAttrs) {\n\n            var expression = tAttrs.akPaginate;\n            // regex taken directly from\n            // https://github.com/angular/angular.js/blob/v1.4.x/src/ng/directive/ngRepeat.js#L339\n            var match = expression.match(/^\\s*([\\s\\S]+?)\\s+in\\s+([\\s\\S]+?)(?:\\s+as\\s+([\\s\\S]+?))?(?:\\s+track\\s+by\\s+([\\s\\S]+?))?\\s*$/);\n\n            var filterPattern = /\\|\\s*itemsPerPage\\s*:\\s*(.*\\(\\s*\\w*\\)|([^\\)]*?(?=\\s+as\\s+))|[^\\)]*)/;\n            if (match[2].match(filterPattern) === null) {\n                throw 'pagination directive: the \\'itemsPerPage\\' filter must be set.';\n            }\n            var itemsPerPageFilterRemoved = match[2].replace(filterPattern, '');\n            var collectionGetter = $parse(itemsPerPageFilterRemoved);\n\n            addNoCompileAttributes(tElement);\n\n            // If any value is specified for paginationId, we register the un-evaluated expression at this stage for\n            // the benefit of any ak-pagination-controls directives that may be looking for this ID.\n            var rawId = tAttrs.paginationId || DEFAULT_ID;\n            paginationService.registerInstance(rawId);\n\n            return function dirPaginationLinkFn(scope, element, attrs) {\n\n                // Now that we have access to the `scope` we can interpolate any expression given in the paginationId\n                // attribute and potentially register a new ID if it evaluates to a different value than the rawId.\n                var paginationId = $parse(attrs.paginationId)(scope) || attrs.paginationId || DEFAULT_ID;\n\n                // (TODO: this seems sound, but I'm reverting as many bug reports followed it's introduction in 0.11.0.\n                // Needs more investigation.)\n                // In case rawId != paginationId we deregister using rawId for the sake of general cleanliness\n                // before registering using paginationId\n                // paginationService.deregisterInstance(rawId);\n                paginationService.registerInstance(paginationId);\n\n                var repeatExpression = getRepeatExpression(expression, paginationId);\n                addNgRepeatToElement(element, attrs, repeatExpression);\n\n                removeTemporaryAttributes(element);\n                var compiled = $compile(element);\n\n                var currentPageGetter = makeCurrentPageGetterFn(scope, attrs, paginationId);\n                paginationService.setCurrentPageParser(paginationId, currentPageGetter, scope);\n\n                if (typeof attrs.totalItems !== 'undefined') {\n                    paginationService.setAsyncModeTrue(paginationId);\n                    scope.$watch(function () {\n                        return $parse(attrs.totalItems)(scope);\n                    }, function (result) {\n                        if (0 <= result) {\n                            paginationService.setCollectionLength(paginationId, result);\n                        }\n                    });\n                }\n                else {\n                    paginationService.setAsyncModeFalse(paginationId);\n                    scope.$watchCollection(function () {\n                        return collectionGetter(scope);\n                    }, function (collection) {\n                        if (collection) {\n                            var collectionLength = (collection instanceof\n                            Array) ? collection.length : Object.keys(collection).length;\n                            paginationService.setCollectionLength(paginationId, collectionLength);\n                        }\n                    });\n                }\n\n                // Delegate to the link function returned by the new compilation of the ng-repeat\n                compiled(scope);\n\n                // (TODO: Reverting this due to many bug reports in v 0.11.0. Needs investigation as the\n                // principle is sound)\n                // When the scope is destroyed, we make sure to remove the reference to it in paginationService\n                // so that it can be properly garbage collected\n                // scope.$on('$destroy', function destroyDirPagination() {\n                //     paginationService.deregisterInstance(paginationId);\n                // });\n            };\n        }\n\n        /**\n         * If a pagination id has been specified, we need to check that it is present as the second argument passed to\n         * the itemsPerPage filter. If it is not there, we add it and return the modified expression.\n         *\n         * @param expression\n         * @param paginationId\n         * @returns {*}\n         */\n        function getRepeatExpression(expression, paginationId) {\n            var repeatExpression,\n                idDefinedInFilter = !!expression.match(/(\\|\\s*itemsPerPage\\s*:[^|]*:[^|]*)/);\n\n            if (paginationId !== DEFAULT_ID && !idDefinedInFilter) {\n                repeatExpression = expression.replace(/(\\|\\s*itemsPerPage\\s*:\\s*[^|\\s]*)/, \"$1 : '\" + paginationId +\n                    \"'\");\n            }\n            else {\n                repeatExpression = expression;\n            }\n\n            return repeatExpression;\n        }\n\n        /**\n         * Adds the ng-repeat directive to the element. In the case of multi-element (-start, -end) it adds the\n         * appropriate multi-element ng-repeat to the first and last element in the range.\n         * @param element\n         * @param attrs\n         * @param repeatExpression\n         */\n        function addNgRepeatToElement(element, attrs, repeatExpression) {\n            if (element[0].hasAttribute('dir-paginate-start') || element[0].hasAttribute('data-dir-paginate-start')) {\n                // using multiElement mode (dir-paginate-start, dir-paginate-end)\n                attrs.$set('ngRepeatStart', repeatExpression);\n                element.eq(element.length - 1)\n                       .attr('ng-repeat-end', true);\n            }\n            else {\n                attrs.$set('ngRepeat', repeatExpression);\n            }\n        }\n\n        /**\n         * Adds the dir-paginate-no-compile directive to each element in the tElement range.\n         * @param tElement\n         */\n        function addNoCompileAttributes(tElement) {\n            angular.forEach(tElement, function (el) {\n                if (el.nodeType === 1) {\n                    angular.element(el)\n                           .attr('dir-paginate-no-compile', true);\n                }\n            });\n        }\n\n        /**\n         * Removes the variations on ak-paginate (data-, -start, -end) and the dir-paginate-no-compile directives.\n         * @param element\n         */\n        function removeTemporaryAttributes(element) {\n            angular.forEach(element, function (el) {\n                if (el.nodeType === 1) {\n                    angular.element(el)\n                           .removeAttr('dir-paginate-no-compile');\n                }\n            });\n            element.eq(0)\n                   .removeAttr('dir-paginate-start')\n                   .removeAttr('ak-paginate')\n                   .removeAttr('data-dir-paginate-start')\n                   .removeAttr('data-ak-paginate');\n            element.eq(element.length - 1)\n                   .removeAttr('dir-paginate-end')\n                   .removeAttr('data-dir-paginate-end');\n        }\n\n        /**\n         * Creates a getter function for the current-page attribute, using the expression provided or a default value if\n         * no current-page expression was specified.\n         *\n         * @param scope\n         * @param attrs\n         * @param paginationId\n         * @returns {*}\n         */\n        function makeCurrentPageGetterFn(scope, attrs, paginationId) {\n            var currentPageGetter;\n            if (attrs.currentPage) {\n                currentPageGetter = $parse(attrs.currentPage);\n            }\n            else {\n                // If the current-page attribute was not set, we'll make our own.\n                // Replace any non-alphanumeric characters which might confuse\n                // the $parse service and give unexpected results.\n                // See https://github.com/michaelbromley/angularUtils/issues/233\n                var defaultCurrentPage = (paginationId + '__currentPage').replace(/\\W/g, '_');\n                scope[defaultCurrentPage] = 1;\n                currentPageGetter = $parse(defaultCurrentPage);\n            }\n            return currentPageGetter;\n        }\n    }\n\n    /**\n     * This is a helper directive that allows correct compilation when in multi-element mode (ie dir-paginate-start,\n     * dir-paginate-end). It is dynamically added to all elements in the ak-paginate compile function, and it prevents\n     * further compilation of any inner directives. It is then removed in the link function, and all inner directives\n     * are then manually compiled.\n     */\n    function noCompileDirective() {\n        return {\n            priority: 5000,\n            terminal: true\n        };\n    }\n\n    function dirPaginationControlsTemplateInstaller($templateCache) {\n        $templateCache.put('angularUtils.directives.dirPagination.template', '<ul class=\"pagination\" ng-if=\"1 < pages.length || !autoHide\"><li ng-if=\"boundaryLinks\" ng-class=\"{ disabled : pagination.current == 1 }\"><a href=\"\" ng-click=\"setCurrent(1)\">&laquo;</a></li><li ng-if=\"directionLinks\" ng-class=\"{ disabled : pagination.current == 1 }\"><a href=\"\" ng-click=\"setCurrent(pagination.current - 1)\">&lsaquo;</a></li><li ng-repeat=\"pageNumber in pages track by tracker(pageNumber, $index)\" ng-class=\"{ active : pagination.current == pageNumber, disabled : pageNumber == \\'...\\' || ( ! autoHide && pages.length === 1 ) }\"><a href=\"\" ng-click=\"setCurrent(pageNumber)\">{{ pageNumber }}</a></li><li ng-if=\"directionLinks\" ng-class=\"{ disabled : pagination.current == pagination.last }\"><a href=\"\" ng-click=\"setCurrent(pagination.current + 1)\">&rsaquo;</a></li><li ng-if=\"boundaryLinks\"  ng-class=\"{ disabled : pagination.current == pagination.last }\"><a href=\"\" ng-click=\"setCurrent(pagination.last)\">&raquo;</a></li></ul>');\n    }\n\n    function akPaginationControlsDirective(paginationService, paginationTemplate) {\n\n        var numberRegex = /^\\d+$/;\n\n        var DDO = {\n            restrict: 'AE',\n            scope:    {\n                maxSize:      '=?',\n                onPageChange: '&?',\n                paginationId: '=?',\n                autoHide:     '=?'\n            },\n            link:     akPaginationControlsLinkFn\n        };\n\n        // We need to check the paginationTemplate service to see whether a template path or\n        // string has been specified, and add the `template` or `templateUrl` property to\n        // the DDO as appropriate. The order of priority to decide which template to use is\n        // (highest priority first):\n        // 1. paginationTemplate.getString()\n        // 2. attrs.templateUrl\n        // 3. paginationTemplate.getPath()\n        var templateString = paginationTemplate.getString();\n        if (templateString !== undefined) {\n            DDO.template = templateString;\n        }\n        else {\n            DDO.templateUrl = function (elem, attrs) {\n                return attrs.templateUrl || paginationTemplate.getPath();\n            };\n        }\n        return DDO;\n\n        function akPaginationControlsLinkFn(scope, element, attrs) {\n\n            // rawId is the un-interpolated value of the pagination-id attribute. This is only important when the\n            // corresponding ak-paginate directive has not yet been linked (e.g. if it is inside an ng-if block), and\n            // in that case it prevents this controls directive from assuming that there is no corresponding\n            // ak-paginate directive and wrongly throwing an exception.\n            var rawId = attrs.paginationId || DEFAULT_ID;\n            var paginationId = scope.paginationId || attrs.paginationId || DEFAULT_ID;\n\n            if (!paginationService.isRegistered(paginationId) && !paginationService.isRegistered(rawId)) {\n                var idMessage = (paginationId !== DEFAULT_ID) ? ' (id: ' + paginationId + ') ' : ' ';\n                if (window.console) {\n                    console.warn('Pagination directive: the pagination controls' + idMessage +\n                        'cannot be used without the corresponding pagination directive, which was not found at link time.');\n                }\n            }\n\n            if (!scope.maxSize) {\n                scope.maxSize = 9;\n            }\n            scope.autoHide = scope.autoHide === undefined ? true : scope.autoHide;\n            scope.directionLinks = angular.isDefined(attrs.directionLinks) ? scope.$parent.$eval(attrs.directionLinks) : true;\n            scope.boundaryLinks = angular.isDefined(attrs.boundaryLinks) ? scope.$parent.$eval(attrs.boundaryLinks) : false;\n\n            var paginationRange = Math.max(scope.maxSize, 5);\n            scope.pages = [];\n            scope.pagination = {\n                last:    1,\n                current: 1\n            };\n            scope.range = {\n                lower: 1,\n                upper: 1,\n                total: 1\n            };\n\n            scope.$watch('maxSize', function (val) {\n                if (val) {\n                    paginationRange = Math.max(scope.maxSize, 5);\n                    generatePagination();\n                }\n            });\n\n            scope.$watch(function () {\n                if (paginationService.isRegistered(paginationId)) {\n                    return (paginationService.getCollectionLength(paginationId) + 1) *\n                        paginationService.getItemsPerPage(paginationId);\n                }\n            }, function (length) {\n                if (0 < length) {\n                    generatePagination();\n                }\n            });\n\n            scope.$watch(function () {\n                if (paginationService.isRegistered(paginationId)) {\n                    return (paginationService.getItemsPerPage(paginationId));\n                }\n            }, function (current, previous) {\n                if (current != previous && typeof previous !== 'undefined') {\n                    goToPage(scope.pagination.current);\n                }\n            });\n\n            scope.$watch(function () {\n                if (paginationService.isRegistered(paginationId)) {\n                    return paginationService.getCurrentPage(paginationId);\n                }\n            }, function (currentPage, previousPage) {\n                if (currentPage != previousPage) {\n                    goToPage(currentPage);\n                }\n            });\n\n            scope.setCurrent = function (num) {\n                if (paginationService.isRegistered(paginationId) && isValidPageNumber(num)) {\n                    num = parseInt(num, 10);\n                    paginationService.setCurrentPage(paginationId, num);\n                }\n            };\n\n            /**\n             * Custom \"track by\" function which allows for duplicate \"...\" entries on long lists,\n             * yet fixes the problem of wrongly-highlighted links which happens when using\n             * \"track by $index\" - see https://github.com/michaelbromley/angularUtils/issues/153\n             * @param id\n             * @param index\n             * @returns {string}\n             */\n            scope.tracker = function (id, index) {\n                return id + '_' + index;\n            };\n\n            function goToPage(num) {\n                if (paginationService.isRegistered(paginationId) && isValidPageNumber(num)) {\n                    var oldPageNumber = scope.pagination.current;\n\n                    scope.pages = generatePagesArray(num, paginationService.getCollectionLength(paginationId), paginationService.getItemsPerPage(paginationId), paginationRange);\n                    scope.pagination.current = num;\n                    updateRangeValues();\n\n                    // if a callback has been set, then call it with the page number as the first argument\n                    // and the previous page number as a second argument\n                    if (scope.onPageChange) {\n                        scope.onPageChange({\n                            newPageNumber: num,\n                            oldPageNumber: oldPageNumber\n                        });\n                    }\n                }\n            }\n\n            function generatePagination() {\n                if (paginationService.isRegistered(paginationId)) {\n                    var page = parseInt(paginationService.getCurrentPage(paginationId)) || 1;\n                    scope.pages = generatePagesArray(page, paginationService.getCollectionLength(paginationId), paginationService.getItemsPerPage(paginationId), paginationRange);\n                    scope.pagination.current = page;\n                    scope.pagination.last = scope.pages[scope.pages.length - 1];\n                    if (scope.pagination.last < scope.pagination.current) {\n                        scope.setCurrent(scope.pagination.last);\n                    }\n                    else {\n                        updateRangeValues();\n                    }\n                }\n            }\n\n            /**\n             * This function updates the values (lower, upper, total) of the `scope.range` object, which can be used in\n             * the pagination template to display the current page range, e.g. \"showing 21 - 40 of 144 results\";\n             */\n            function updateRangeValues() {\n                if (paginationService.isRegistered(paginationId)) {\n                    var currentPage = paginationService.getCurrentPage(paginationId),\n                        itemsPerPage = paginationService.getItemsPerPage(paginationId),\n                        totalItems = paginationService.getCollectionLength(paginationId);\n\n                    scope.range.lower = (currentPage - 1) * itemsPerPage + 1;\n                    scope.range.upper = Math.min(currentPage * itemsPerPage, totalItems);\n                    scope.range.total = totalItems;\n                }\n            }\n\n            function isValidPageNumber(num) {\n                return (numberRegex.test(num) && (0 < num && num <= scope.pagination.last));\n            }\n        }\n\n        /**\n         * Generate an array of page numbers (or the '...' string) which is used in an ng-repeat to generate the\n         * links used in pagination\n         *\n         * @param currentPage\n         * @param rowsPerPage\n         * @param paginationRange\n         * @param collectionLength\n         * @returns {Array}\n         */\n        function generatePagesArray(currentPage, collectionLength, rowsPerPage, paginationRange) {\n            var pages = [];\n            var totalPages = Math.ceil(collectionLength / rowsPerPage);\n            var halfWay = Math.ceil(paginationRange / 2);\n            var position;\n\n            if (currentPage <= halfWay) {\n                position = 'start';\n            }\n            else if (totalPages - halfWay < currentPage) {\n                position = 'end';\n            }\n            else {\n                position = 'middle';\n            }\n\n            var ellipsesNeeded = paginationRange < totalPages;\n            var i = 1;\n            while (i <= totalPages && i <= paginationRange) {\n                var pageNumber = calculatePageNumber(i, currentPage, paginationRange, totalPages);\n\n                var openingEllipsesNeeded = (i === 2 && (position === 'middle' || position === 'end'));\n                var closingEllipsesNeeded = (i === paginationRange - 1 &&\n                (position === 'middle' || position === 'start'));\n                if (ellipsesNeeded && (openingEllipsesNeeded || closingEllipsesNeeded)) {\n                    pages.push('...');\n                }\n                else {\n                    pages.push(pageNumber);\n                }\n                i++;\n            }\n            return pages;\n        }\n\n        /**\n         * Given the position in the sequence of pagination links [i], figure out what page number corresponds to that\n         * position.\n         *\n         * @param i\n         * @param currentPage\n         * @param paginationRange\n         * @param totalPages\n         * @returns {*}\n         */\n        function calculatePageNumber(i, currentPage, paginationRange, totalPages) {\n            var halfWay = Math.ceil(paginationRange / 2);\n            if (i === paginationRange) {\n                return totalPages;\n            }\n            else if (i === 1) {\n                return i;\n            }\n            else if (paginationRange < totalPages) {\n                if (totalPages - halfWay < currentPage) {\n                    return totalPages - paginationRange + i;\n                }\n                else if (halfWay < currentPage) {\n                    return currentPage - halfWay + i;\n                }\n                else {\n                    return i;\n                }\n            }\n            else {\n                return i;\n            }\n        }\n    }\n\n    /**\n     * This filter slices the collection into pages based on the current page number and number of items per page.\n     * @param paginationService\n     * @returns {Function}\n     */\n    function itemsPerPageFilter(paginationService) {\n\n        return function (collection, itemsPerPage, paginationId) {\n            if (typeof (paginationId) === 'undefined') {\n                paginationId = DEFAULT_ID;\n            }\n            if (!paginationService.isRegistered(paginationId)) {\n                throw 'pagination directive: the itemsPerPage id argument (id: ' + paginationId +\n                ') does not match a registered pagination-id.';\n            }\n            var end;\n            var start;\n            if (angular.isObject(collection)) {\n                itemsPerPage = parseInt(itemsPerPage) || 9999999999;\n                if (paginationService.isAsyncMode(paginationId)) {\n                    start = 0;\n                }\n                else {\n                    start = (paginationService.getCurrentPage(paginationId) - 1) * itemsPerPage;\n                }\n                end = start + itemsPerPage;\n                paginationService.setItemsPerPage(paginationId, itemsPerPage);\n\n                if (collection instanceof Array) {\n                    // the array just needs to be sliced\n                    return collection.slice(start, end);\n                }\n                else {\n                    // in the case of an object, we need to get an array of keys, slice that, then map back to\n                    // the original object.\n                    var slicedObject = {};\n                    angular.forEach(keys(collection)\n                        .slice(start, end), function (key) {\n                        slicedObject[key] = collection[key];\n                    });\n                    return slicedObject;\n                }\n            }\n            else {\n                return collection;\n            }\n        };\n    }\n\n    /**\n     * Shim for the Object.keys() method which does not exist in IE < 9\n     * @param obj\n     * @returns {Array}\n     */\n    function keys(obj) {\n        if (!Object.keys) {\n            var objKeys = [];\n            for (var i in obj) {\n                if (obj.hasOwnProperty(i)) {\n                    objKeys.push(i);\n                }\n            }\n            return objKeys;\n        }\n        else {\n            return Object.keys(obj);\n        }\n    }\n\n    /**\n     * This service allows the various parts of the module to communicate and stay in sync.\n     */\n    function paginationService() {\n\n        var instances = {};\n        var lastRegisteredInstance;\n\n        this.registerInstance = function (instanceId) {\n            if (typeof instances[instanceId] === 'undefined') {\n                instances[instanceId] = {\n                    asyncMode: false\n                };\n                lastRegisteredInstance = instanceId;\n            }\n        };\n\n        this.deregisterInstance = function (instanceId) {\n            delete instances[instanceId];\n        };\n\n        this.isRegistered = function (instanceId) {\n            return (typeof instances[instanceId] !== 'undefined');\n        };\n\n        this.getLastInstanceId = function () {\n            return lastRegisteredInstance;\n        };\n\n        this.setCurrentPageParser = function (instanceId, val, scope) {\n            instances[instanceId].currentPageParser = val;\n            instances[instanceId].context = scope;\n        };\n        this.setCurrentPage = function (instanceId, val) {\n            instances[instanceId].currentPageParser.assign(instances[instanceId].context, val);\n        };\n        this.getCurrentPage = function (instanceId) {\n            var parser = instances[instanceId].currentPageParser;\n            return parser ? parser(instances[instanceId].context) : 1;\n        };\n\n        this.setItemsPerPage = function (instanceId, val) {\n            instances[instanceId].itemsPerPage = val;\n        };\n        this.getItemsPerPage = function (instanceId) {\n            return instances[instanceId].itemsPerPage;\n        };\n\n        this.setCollectionLength = function (instanceId, val) {\n            instances[instanceId].collectionLength = val;\n        };\n        this.getCollectionLength = function (instanceId) {\n            return instances[instanceId].collectionLength;\n        };\n\n        this.setAsyncModeTrue = function (instanceId) {\n            instances[instanceId].asyncMode = true;\n        };\n\n        this.setAsyncModeFalse = function (instanceId) {\n            instances[instanceId].asyncMode = false;\n        };\n\n        this.isAsyncMode = function (instanceId) {\n            return instances[instanceId].asyncMode;\n        };\n    }\n\n    /**\n     * This provider allows global configuration of the template path used by the ak-pagination-controls directive.\n     */\n    function paginationTemplateProvider() {\n\n        var templatePath = 'angularUtils.directives.dirPagination.template';\n        var templateString;\n\n        /**\n         * Set a templateUrl to be used by all instances of <ak-pagination-controls>\n         * @param {String} path\n         */\n        this.setPath = function (path) {\n            templatePath = path;\n        };\n\n        /**\n         * Set a string of HTML to be used as a template by all instances\n         * of <ak-pagination-controls>. If both a path *and* a string have been set,\n         * the string takes precedence.\n         * @param {String} str\n         */\n        this.setString = function (str) {\n            templateString = str;\n        };\n\n        this.$get = function () {\n            return {\n                getPath:   function () {\n                    return templatePath;\n                },\n                getString: function () {\n                    return templateString;\n                }\n            };\n        };\n    }\n})();\n})();"]}