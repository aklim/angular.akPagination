{"version":3,"sources":["angular.akPagination.min.js"],"names":["akPaginationDirective","$compile","$parse","paginationService","dirPaginationCompileFn","tElement","tAttrs","expression","akPagination","match","filterPattern","itemsPerPageFilterRemoved","replace","collectionGetter","addNoCompileAttributes","rawId","paginationId","DEFAULT_ID","registerInstance","scope","element","attrs","repeatExpression","getRepeatExpression","addNgRepeatToElement","removeTemporaryAttributes","compiled","currentPageGetter","makeCurrentPageGetterFn","setCurrentPageParser","totalItems","setAsyncModeTrue","$watch","result","setCollectionLength","setAsyncModeFalse","$watchCollection","collection","collectionLength","Array","length","Object","keys","idDefinedInFilter","hasAttribute","$set","eq","attr","angular","forEach","el","nodeType","removeAttr","currentPage","defaultCurrentPage","terminal","multiElement","priority","compile","paginationControlsDirective","paginationTemplate","paginationControlsLinkFn","goToPage","num","isRegistered","isValidPageNumber","oldPageNumber","pagination","current","pages","generatePagesArray","getCollectionLength","getItemsPerPage","paginationRange","updateRangeValues","onPageChange","newPageNumber","generatePagination","page","parseInt","getCurrentPage","last","setCurrent","itemsPerPage","range","lower","upper","Math","min","total","numberRegex","test","idMessage","window","console","warn","maxSize","autoHide","undefined","directionLinks","isDefined","$parent","$eval","boundaryLinks","max","val","previous","previousPage","setCurrentPage","tracker","id","index","rowsPerPage","position","totalPages","ceil","halfWay","ellipsesNeeded","i","pageNumber","calculatePageNumber","openingEllipsesNeeded","closingEllipsesNeeded","push","DDO","restrict","link","templateString","getString","template","templateUrl","elem","getPath","noCompileDirective","itemsPerPageFilter","end","start","isObject","isAsyncMode","setItemsPerPage","slice","slicedObject","key","lastRegisteredInstance","instances","this","instanceId","asyncMode","deregisterInstance","getLastInstanceId","currentPageParser","context","assign","parser","paginationControlsTemplateInstaller","$templateCache","put","paginationTemplateProvider","templatePath","setPath","path","setString","str","$get","module","directive","filter","service","provider","run"],"mappings":"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","file":"angular.akPagination.min.js","sourcesContent":["\"use strict\";\n\n(function() {\n/**\n * angular.akPagination - AngularJS pagination module.\n *\n * Copyright 2017 Andrey Klimenko <andrey.iemail@gmail.com>\n */\n\n(function () {\n    /* Config */\n    var DEFAULT_ID = '__default';\n\n    angular\n        .module('angular.akPagination', [])\n        .directive('akPagination', ['$compile', '$parse', 'paginationService', akPaginationDirective])\n        .directive('dirPaginateNoCompile', noCompileDirective)\n        .directive('dirPaginationControls', ['paginationService', 'paginationTemplate', paginationControlsDirective])\n        .filter('itemsPerPage', ['paginationService', itemsPerPageFilter])\n        .service('paginationService', paginationService)\n        .provider('paginationTemplate', paginationTemplateProvider)\n        .run(['$templateCache', paginationControlsTemplateInstaller]);\n\n    //region Pagination directive\n    function akPaginationDirective($compile, $parse, paginationService) {\n\n        return {\n            terminal:     true,\n            multiElement: true,\n            priority:     100,\n            compile:      dirPaginationCompileFn\n        };\n\n        function dirPaginationCompileFn(tElement, tAttrs) {\n\n            var expression = tAttrs.akPagination;\n            // regex taken directly from\n            // https://github.com/angular/angular.js/blob/v1.4.x/src/ng/directive/ngRepeat.js#L339\n            var match = expression.match(/^\\s*([\\s\\S]+?)\\s+in\\s+([\\s\\S]+?)(?:\\s+as\\s+([\\s\\S]+?))?(?:\\s+track\\s+by\\s+([\\s\\S]+?))?\\s*$/);\n\n            var filterPattern = /\\|\\s*itemsPerPage\\s*:\\s*(.*\\(\\s*\\w*\\)|([^\\)]*?(?=\\s+as\\s+))|[^\\)]*)/;\n            if (match[2].match(filterPattern) === null) {\n                throw 'pagination directive: the \\'itemsPerPage\\' filter must be set.';\n            }\n            var itemsPerPageFilterRemoved = match[2].replace(filterPattern, '');\n            var collectionGetter = $parse(itemsPerPageFilterRemoved);\n\n            addNoCompileAttributes(tElement);\n\n            // If any value is specified for paginationId, we register the un-evaluated expression at this stage for\n            // the benefit of any dir-pagination-controls directives that may be looking for this ID.\n            var rawId = tAttrs.paginationId || DEFAULT_ID;\n            paginationService.registerInstance(rawId);\n\n            return function dirPaginationLinkFn(scope, element, attrs) {\n\n                // Now that we have access to the `scope` we can interpolate any expression given in the paginationId\n                // attribute and potentially register a new ID if it evaluates to a different value than the rawId.\n                var paginationId = $parse(attrs.paginationId)(scope) || attrs.paginationId || DEFAULT_ID;\n\n                // (TODO: this seems sound, but I'm reverting as many bug reports followed it's introduction in 0.11.0.\n                // Needs more investigation.)\n                // In case rawId != paginationId we deregister using rawId for the sake of general cleanliness\n                // before registering using paginationId\n                // paginationService.deregisterInstance(rawId);\n                paginationService.registerInstance(paginationId);\n\n                var repeatExpression = getRepeatExpression(expression, paginationId);\n                addNgRepeatToElement(element, attrs, repeatExpression);\n\n                removeTemporaryAttributes(element);\n                var compiled = $compile(element);\n\n                var currentPageGetter = makeCurrentPageGetterFn(scope, attrs, paginationId);\n                paginationService.setCurrentPageParser(paginationId, currentPageGetter, scope);\n\n                if (typeof attrs.totalItems !== 'undefined') {\n                    paginationService.setAsyncModeTrue(paginationId);\n                    scope.$watch(function () {\n                        return $parse(attrs.totalItems)(scope);\n                    }, function (result) {\n                        if (0 <= result) {\n                            paginationService.setCollectionLength(paginationId, result);\n                        }\n                    });\n                }\n                else {\n                    paginationService.setAsyncModeFalse(paginationId);\n                    scope.$watchCollection(function () {\n                        return collectionGetter(scope);\n                    }, function (collection) {\n                        if (collection) {\n                            var collectionLength = (collection instanceof\n                            Array) ? collection.length : Object.keys(collection).length;\n                            paginationService.setCollectionLength(paginationId, collectionLength);\n                        }\n                    });\n                }\n\n                // Delegate to the link function returned by the new compilation of the ng-repeat\n                compiled(scope);\n\n                // (TODO: Reverting this due to many bug reports in v 0.11.0. Needs investigation as the\n                // principle is sound)\n                // When the scope is destroyed, we make sure to remove the reference to it in paginationService\n                // so that it can be properly garbage collected\n                // scope.$on('$destroy', function destroyDirPagination() {\n                //     paginationService.deregisterInstance(paginationId);\n                // });\n            };\n        }\n\n        /**\n         * If a pagination id has been specified, we need to check that it is present as the second argument passed to\n         * the itemsPerPage filter. If it is not there, we add it and return the modified expression.\n         *\n         * @param expression\n         * @param paginationId\n         * @returns {*}\n         */\n        function getRepeatExpression(expression, paginationId) {\n            var repeatExpression,\n                idDefinedInFilter = !!expression.match(/(\\|\\s*itemsPerPage\\s*:[^|]*:[^|]*)/);\n\n            if (paginationId !== DEFAULT_ID && !idDefinedInFilter) {\n                repeatExpression = expression.replace(/(\\|\\s*itemsPerPage\\s*:\\s*[^|\\s]*)/, \"$1 : '\" + paginationId +\n                    \"'\");\n            }\n            else {\n                repeatExpression = expression;\n            }\n\n            return repeatExpression;\n        }\n\n        /**\n         * Adds the ng-repeat directive to the element. In the case of multi-element (-start, -end) it adds the\n         * appropriate multi-element ng-repeat to the first and last element in the range.\n         * @param element\n         * @param attrs\n         * @param repeatExpression\n         */\n        function addNgRepeatToElement(element, attrs, repeatExpression) {\n            if (element[0].hasAttribute('dir-paginate-start') || element[0].hasAttribute('data-dir-paginate-start')) {\n                // using multiElement mode (dir-paginate-start, dir-paginate-end)\n                attrs.$set('ngRepeatStart', repeatExpression);\n                element.eq(element.length - 1)\n                       .attr('ng-repeat-end', true);\n            }\n            else {\n                attrs.$set('ngRepeat', repeatExpression);\n            }\n        }\n\n        /**\n         * Adds the dir-paginate-no-compile directive to each element in the tElement range.\n         * @param tElement\n         */\n        function addNoCompileAttributes(tElement) {\n            angular.forEach(tElement, function (el) {\n                if (el.nodeType === 1) {\n                    angular.element(el)\n                           .attr('dir-paginate-no-compile', true);\n                }\n            });\n        }\n\n        /**\n         * Removes the variations on dir-paginate (data-, -start, -end) and the dir-paginate-no-compile directives.\n         * @param element\n         */\n        function removeTemporaryAttributes(element) {\n            angular.forEach(element, function (el) {\n                if (el.nodeType === 1) {\n                    angular.element(el)\n                           .removeAttr('dir-paginate-no-compile');\n                }\n            });\n            element.eq(0)\n                   .removeAttr('dir-paginate-start')\n                   .removeAttr('dir-paginate')\n                   .removeAttr('data-dir-paginate-start')\n                   .removeAttr('data-dir-paginate');\n            element.eq(element.length - 1)\n                   .removeAttr('dir-paginate-end')\n                   .removeAttr('data-dir-paginate-end');\n        }\n\n        /**\n         * Creates a getter function for the current-page attribute, using the expression provided or a default value if\n         * no current-page expression was specified.\n         *\n         * @param scope\n         * @param attrs\n         * @param paginationId\n         * @returns {*}\n         */\n        function makeCurrentPageGetterFn(scope, attrs, paginationId) {\n            var currentPageGetter;\n            if (attrs.currentPage) {\n                currentPageGetter = $parse(attrs.currentPage);\n            }\n            else {\n                // If the current-page attribute was not set, we'll make our own.\n                // Replace any non-alphanumeric characters which might confuse\n                // the $parse service and give unexpected results.\n                // See https://github.com/michaelbromley/angularUtils/issues/233\n                var defaultCurrentPage = (paginationId + '__currentPage').replace(/\\W/g, '_');\n                scope[defaultCurrentPage] = 1;\n                currentPageGetter = $parse(defaultCurrentPage);\n            }\n            return currentPageGetter;\n        }\n    }\n\n    //endregion\n\n    //region pagination control directive\n    function paginationControlsDirective(paginationService, paginationTemplate) {\n\n        var numberRegex = /^\\d+$/;\n\n        var DDO = {\n            restrict: 'AE',\n            scope:    {\n                maxSize:      '=?',\n                onPageChange: '&?',\n                paginationId: '=?',\n                autoHide:     '=?'\n            },\n            link:     paginationControlsLinkFn\n        };\n\n        // We need to check the paginationTemplate service to see whether a template path or\n        // string has been specified, and add the `template` or `templateUrl` property to\n        // the DDO as appropriate. The order of priority to decide which template to use is\n        // (highest priority first):\n        // 1. paginationTemplate.getString()\n        // 2. attrs.templateUrl\n        // 3. paginationTemplate.getPath()\n        var templateString = paginationTemplate.getString();\n        if (templateString !== undefined) {\n            DDO.template = templateString;\n        }\n        else {\n            DDO.templateUrl = function (elem, attrs) {\n                return attrs.templateUrl || paginationTemplate.getPath();\n            };\n        }\n        return DDO;\n\n        function paginationControlsLinkFn(scope, element, attrs) {\n\n            // rawId is the un-interpolated value of the pagination-id attribute. This is only important when the\n            // corresponding dir-paginate directive has not yet been linked (e.g. if it is inside an ng-if block), and\n            // in that case it prevents this controls directive from assuming that there is no corresponding\n            // dir-paginate directive and wrongly throwing an exception.\n            var rawId = attrs.paginationId || DEFAULT_ID;\n            var paginationId = scope.paginationId || attrs.paginationId || DEFAULT_ID;\n\n            if (!paginationService.isRegistered(paginationId) && !paginationService.isRegistered(rawId)) {\n                var idMessage = (paginationId !== DEFAULT_ID) ? ' (id: ' + paginationId + ') ' : ' ';\n                if (window.console) {\n                    console.warn('Pagination directive: the pagination controls' + idMessage +\n                        'cannot be used without the corresponding pagination directive, which was not found at link time.');\n                }\n            }\n\n            if (!scope.maxSize) {\n                scope.maxSize = 9;\n            }\n            scope.autoHide = scope.autoHide === undefined ? true : scope.autoHide;\n            scope.directionLinks = angular.isDefined(attrs.directionLinks) ? scope.$parent.$eval(attrs.directionLinks) : true;\n            scope.boundaryLinks = angular.isDefined(attrs.boundaryLinks) ? scope.$parent.$eval(attrs.boundaryLinks) : false;\n\n            var paginationRange = Math.max(scope.maxSize, 5);\n            scope.pages = [];\n            scope.pagination = {\n                last:    1,\n                current: 1\n            };\n            scope.range = {\n                lower: 1,\n                upper: 1,\n                total: 1\n            };\n\n            scope.$watch('maxSize', function (val) {\n                if (val) {\n                    paginationRange = Math.max(scope.maxSize, 5);\n                    generatePagination();\n                }\n            });\n\n            scope.$watch(function () {\n                if (paginationService.isRegistered(paginationId)) {\n                    return (paginationService.getCollectionLength(paginationId) + 1) *\n                        paginationService.getItemsPerPage(paginationId);\n                }\n            }, function (length) {\n                if (0 < length) {\n                    generatePagination();\n                }\n            });\n\n            scope.$watch(function () {\n                if (paginationService.isRegistered(paginationId)) {\n                    return (paginationService.getItemsPerPage(paginationId));\n                }\n            }, function (current, previous) {\n                if (current != previous && typeof previous !== 'undefined') {\n                    goToPage(scope.pagination.current);\n                }\n            });\n\n            scope.$watch(function () {\n                if (paginationService.isRegistered(paginationId)) {\n                    return paginationService.getCurrentPage(paginationId);\n                }\n            }, function (currentPage, previousPage) {\n                if (currentPage != previousPage) {\n                    goToPage(currentPage);\n                }\n            });\n\n            scope.setCurrent = function (num) {\n                if (paginationService.isRegistered(paginationId) && isValidPageNumber(num)) {\n                    num = parseInt(num, 10);\n                    paginationService.setCurrentPage(paginationId, num);\n                }\n            };\n\n            /**\n             * Custom \"track by\" function which allows for duplicate \"...\" entries on long lists,\n             * yet fixes the problem of wrongly-highlighted links which happens when using\n             * \"track by $index\" - see https://github.com/michaelbromley/angularUtils/issues/153\n             * @param id\n             * @param index\n             * @returns {string}\n             */\n            scope.tracker = function (id, index) {\n                return id + '_' + index;\n            };\n\n            function goToPage(num) {\n                if (paginationService.isRegistered(paginationId) && isValidPageNumber(num)) {\n                    var oldPageNumber = scope.pagination.current;\n\n                    scope.pages = generatePagesArray(num, paginationService.getCollectionLength(paginationId), paginationService.getItemsPerPage(paginationId), paginationRange);\n                    scope.pagination.current = num;\n                    updateRangeValues();\n\n                    // if a callback has been set, then call it with the page number as the first argument\n                    // and the previous page number as a second argument\n                    if (scope.onPageChange) {\n                        scope.onPageChange({\n                            newPageNumber: num,\n                            oldPageNumber: oldPageNumber\n                        });\n                    }\n                }\n            }\n\n            function generatePagination() {\n                if (paginationService.isRegistered(paginationId)) {\n                    var page = parseInt(paginationService.getCurrentPage(paginationId)) || 1;\n                    scope.pages = generatePagesArray(page, paginationService.getCollectionLength(paginationId), paginationService.getItemsPerPage(paginationId), paginationRange);\n                    scope.pagination.current = page;\n                    scope.pagination.last = scope.pages[scope.pages.length - 1];\n                    if (scope.pagination.last < scope.pagination.current) {\n                        scope.setCurrent(scope.pagination.last);\n                    }\n                    else {\n                        updateRangeValues();\n                    }\n                }\n            }\n\n            /**\n             * This function updates the values (lower, upper, total) of the `scope.range` object, which can be used in\n             * the pagination template to display the current page range, e.g. \"showing 21 - 40 of 144 results\";\n             */\n            function updateRangeValues() {\n                if (paginationService.isRegistered(paginationId)) {\n                    var currentPage = paginationService.getCurrentPage(paginationId),\n                        itemsPerPage = paginationService.getItemsPerPage(paginationId),\n                        totalItems = paginationService.getCollectionLength(paginationId);\n\n                    scope.range.lower = (currentPage - 1) * itemsPerPage + 1;\n                    scope.range.upper = Math.min(currentPage * itemsPerPage, totalItems);\n                    scope.range.total = totalItems;\n                }\n            }\n\n            function isValidPageNumber(num) {\n                return (numberRegex.test(num) && (0 < num && num <= scope.pagination.last));\n            }\n        }\n\n        /**\n         * Generate an array of page numbers (or the '...' string) which is used in an ng-repeat to generate the\n         * links used in pagination\n         *\n         * @param currentPage\n         * @param rowsPerPage\n         * @param paginationRange\n         * @param collectionLength\n         * @returns {Array}\n         */\n        function generatePagesArray(currentPage, collectionLength, rowsPerPage, paginationRange) {\n            var pages = [];\n            var totalPages = Math.ceil(collectionLength / rowsPerPage);\n            var halfWay = Math.ceil(paginationRange / 2);\n            var position;\n\n            if (currentPage <= halfWay) {\n                position = 'start';\n            }\n            else if (totalPages - halfWay < currentPage) {\n                position = 'end';\n            }\n            else {\n                position = 'middle';\n            }\n\n            var ellipsesNeeded = paginationRange < totalPages;\n            var i = 1;\n            while (i <= totalPages && i <= paginationRange) {\n                var pageNumber = calculatePageNumber(i, currentPage, paginationRange, totalPages);\n\n                var openingEllipsesNeeded = (i === 2 && (position === 'middle' || position === 'end'));\n                var closingEllipsesNeeded = (i === paginationRange - 1 &&\n                (position === 'middle' || position === 'start'));\n                if (ellipsesNeeded && (openingEllipsesNeeded || closingEllipsesNeeded)) {\n                    pages.push('...');\n                }\n                else {\n                    pages.push(pageNumber);\n                }\n                i++;\n            }\n            return pages;\n        }\n\n        /**\n         * Given the position in the sequence of pagination links [i], figure out what page number corresponds to that\n         * position.\n         *\n         * @param i\n         * @param currentPage\n         * @param paginationRange\n         * @param totalPages\n         * @returns {*}\n         */\n        function calculatePageNumber(i, currentPage, paginationRange, totalPages) {\n            var halfWay = Math.ceil(paginationRange / 2);\n            if (i === paginationRange) {\n                return totalPages;\n            }\n            else if (i === 1) {\n                return i;\n            }\n            else if (paginationRange < totalPages) {\n                if (totalPages - halfWay < currentPage) {\n                    return totalPages - paginationRange + i;\n                }\n                else if (halfWay < currentPage) {\n                    return currentPage - halfWay + i;\n                }\n                else {\n                    return i;\n                }\n            }\n            else {\n                return i;\n            }\n        }\n    }\n\n    //endregion\n\n    //region noCompileDirective\n    /**\n     * This is a helper directive that allows correct compilation when in multi-element mode (ie dir-paginate-start,\n     * dir-paginate-end). It is dynamically added to all elements in the dir-paginate compile function, and it prevents\n     * further compilation of any inner directives. It is then removed in the link function, and all inner directives\n     * are then manually compiled.\n     */\n    function noCompileDirective() {\n        return {\n            priority: 5000,\n            terminal: true\n        };\n    }\n\n    //endregion\n\n    //region pagination filter\n    /**\n     * This filter slices the collection into pages based on the current page number and number of items per page.\n     * @param paginationService\n     * @returns {Function}\n     */\n    function itemsPerPageFilter(paginationService) {\n\n        return function (collection, itemsPerPage, paginationId) {\n            if (typeof (paginationId) === 'undefined') {\n                paginationId = DEFAULT_ID;\n            }\n            if (!paginationService.isRegistered(paginationId)) {\n                throw 'pagination directive: the itemsPerPage id argument (id: ' + paginationId +\n                ') does not match a registered pagination-id.';\n            }\n            var end;\n            var start;\n            if (angular.isObject(collection)) {\n                itemsPerPage = parseInt(itemsPerPage) || 9999999999;\n                if (paginationService.isAsyncMode(paginationId)) {\n                    start = 0;\n                }\n                else {\n                    start = (paginationService.getCurrentPage(paginationId) - 1) * itemsPerPage;\n                }\n                end = start + itemsPerPage;\n                paginationService.setItemsPerPage(paginationId, itemsPerPage);\n\n                if (collection instanceof Array) {\n                    // the array just needs to be sliced\n                    return collection.slice(start, end);\n                }\n                else {\n                    // in the case of an object, we need to get an array of keys, slice that, then map back to\n                    // the original object.\n                    var slicedObject = {};\n                    angular.forEach(keys(collection)\n                        .slice(start, end), function (key) {\n                        slicedObject[key] = collection[key];\n                    });\n                    return slicedObject;\n                }\n            }\n            else {\n                return collection;\n            }\n        };\n    }\n\n    //endregion\n\n    //region pagination service\n    /**\n     * This service allows the various parts of the module to communicate and stay in sync.\n     */\n    function paginationService() {\n\n        var instances = {};\n        var lastRegisteredInstance;\n\n        this.registerInstance = function (instanceId) {\n            if (typeof instances[instanceId] === 'undefined') {\n                instances[instanceId] = {\n                    asyncMode: false\n                };\n                lastRegisteredInstance = instanceId;\n            }\n        };\n\n        this.deregisterInstance = function (instanceId) {\n            delete instances[instanceId];\n        };\n\n        this.isRegistered = function (instanceId) {\n            return (typeof instances[instanceId] !== 'undefined');\n        };\n\n        this.getLastInstanceId = function () {\n            return lastRegisteredInstance;\n        };\n\n        this.setCurrentPageParser = function (instanceId, val, scope) {\n            instances[instanceId].currentPageParser = val;\n            instances[instanceId].context = scope;\n        };\n        this.setCurrentPage = function (instanceId, val) {\n            instances[instanceId].currentPageParser.assign(instances[instanceId].context, val);\n        };\n        this.getCurrentPage = function (instanceId) {\n            var parser = instances[instanceId].currentPageParser;\n            return parser ? parser(instances[instanceId].context) : 1;\n        };\n\n        this.setItemsPerPage = function (instanceId, val) {\n            instances[instanceId].itemsPerPage = val;\n        };\n        this.getItemsPerPage = function (instanceId) {\n            return instances[instanceId].itemsPerPage;\n        };\n\n        this.setCollectionLength = function (instanceId, val) {\n            instances[instanceId].collectionLength = val;\n        };\n        this.getCollectionLength = function (instanceId) {\n            return instances[instanceId].collectionLength;\n        };\n\n        this.setAsyncModeTrue = function (instanceId) {\n            instances[instanceId].asyncMode = true;\n        };\n\n        this.setAsyncModeFalse = function (instanceId) {\n            instances[instanceId].asyncMode = false;\n        };\n\n        this.isAsyncMode = function (instanceId) {\n            return instances[instanceId].asyncMode;\n        };\n\n    }\n\n    //endregion\n\n    //region run handler\n    function paginationControlsTemplateInstaller($templateCache) {\n        $templateCache.put('angular.akPagination.template', '<ul class=\"pagination\" ng-if=\"1 < pages.length || !autoHide\"><li ng-if=\"boundaryLinks\" ng-class=\"{ disabled : pagination.current == 1 }\"><a href=\"\" ng-click=\"setCurrent(1)\">&laquo;</a></li><li ng-if=\"directionLinks\" ng-class=\"{ disabled : pagination.current == 1 }\"><a href=\"\" ng-click=\"setCurrent(pagination.current - 1)\">&lsaquo;</a></li><li ng-repeat=\"pageNumber in pages track by tracker(pageNumber, $index)\" ng-class=\"{ active : pagination.current == pageNumber, disabled : pageNumber == \\'...\\' || ( ! autoHide && pages.length === 1 ) }\"><a href=\"\" ng-click=\"setCurrent(pageNumber)\">{{ pageNumber }}</a></li><li ng-if=\"directionLinks\" ng-class=\"{ disabled : pagination.current == pagination.last }\"><a href=\"\" ng-click=\"setCurrent(pagination.current + 1)\">&rsaquo;</a></li><li ng-if=\"boundaryLinks\"  ng-class=\"{ disabled : pagination.current == pagination.last }\"><a href=\"\" ng-click=\"setCurrent(pagination.last)\">&raquo;</a></li></ul>');\n    }\n\n    //endregion\n\n    //region paginationTemplateProvider\n    /**\n     * This provider allows global configuration of the template path used by the akPagination directive.\n     */\n    function paginationTemplateProvider() {\n\n        var templatePath = 'angular.akPagination.template';\n        var templateString;\n\n        /**\n         * Set a templateUrl to be used by all instances of <ak-pagination>\n         * @param {String} path\n         */\n        this.setPath = function (path) {\n            templatePath = path;\n        };\n\n        /**\n         * Set a string of HTML to be used as a template by all instances\n         * of <ak-pagination>. If both a path *and* a string have been set,\n         * the string takes precedence.\n         * @param {String} str\n         */\n        this.setString = function (str) {\n            templateString = str;\n        };\n\n        this.$get = function () {\n\n            return {\n                getPath:   function () {\n                    return templatePath;\n                },\n                getString: function () {\n                    return templateString;\n                }\n            };\n        };\n\n    }\n\n    //endregion\n})();\n})();"]}